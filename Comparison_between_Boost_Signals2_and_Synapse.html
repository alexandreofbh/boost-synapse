<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN'
'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>
<head>
	<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
	<title>Comparison between Boost.Signals2 and Synapse</title>
	<link href='reno.css' type='text/css' rel='stylesheet'/>
</head>
<body>
<div class="body-0">
<div class="body-1">
<div class="body-2">
<div>
<h1><a href="index.html">Boost Synapse</a></h1>
</div>
<!-- Copyright (c) 2015 Emil Dotchevski and Reverge Studios, Inc. -->
<!-- Distributed under the Boost Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<div class="RenoIncludeDIV"><div class="RenoAutoDIV"><h2>Comparison Between Boost.Signals2 and Synapse</h2>
</div>
<h3>Definition of terms</h3>
<p>Signal programming libraries use the following concepts:</p>
<div><ul><li><i>emitters</i></li>
<li><i>signals</i></li>
<li><i>slots</i></li>
<li><i>connections</i></li>
</ul></div>
<p>As an example, consider a simple "ok" dialog box in any user interface system. When the button is clicked, we want the dialog box to be "accepted" (closed).</p>
<p>To express this in terms of signal programming:</p>
<div><ul><li>The button is the <i>emitter</i> object;</li>
<li>When the button is clicked, it emits a "button_clicked" <i>signal</i>;</li>
<li>The dialog box has a member function "accept", which acts as a <i>slot</i>.</li>
</ul></div>
<p>If we connect the "button_clicked" <i>signal</i> from the button to the "accept" <i>slot</i> on the dialog box, as long as the <i>connection</i> exists, clicking the button will accept (close) the dialog box.</p>
<p>Naturally, <i>signals</i> may carry additional information in the form of arguments, much like functions. So, to connect a <i>signal</i> to a <i>slot</i>, their signatures must match.</p>
<p>Both <i>Signals2</i> and <i>Synapse</i> diverge (in their own way) from the classic paradigm described above.</p>
<h3>Signals2</h3>
<p>In <i>Signals2</i>, signals are simply objects that are callable (in C++ terms). To connect a signal, we call the signal object's connect member function, passing the function we want to connect. To emit a signal, we simply <i>call</i> the signal object, which calls all connected functions (if any).</p>
<p>Here is the above example in terms of <i>Signals2</i>:</p>
<pre>class button
{
  ....
public:
  signal&lt;void()&gt; button_clicked;
};

class dialog_box
{
  ....
public:
  void accept();
};</pre>
<p>To connect:</p>
<pre>dialog_box d;
button b;
b.button_clicked.connect(bind(&amp;dialog_box::accept,&amp;d));</pre>
<p>To emit:</p>
<pre>b.button_clicked();</pre>
<p>Things to note:</p>
<div><ul><li>Emitters are implicit: the emitter (if anyone cares about it) is simply the object which has the member signal objects;</li>
<li>Slots are simply functions, that is, they don't have to belong to an object;</li>
<li>The different semantics of different signals are expressed by the different names given to signal objects. How do we know the signal we're emitting or connecting is "button_clicked" (as opposed to another signal that has the same signature)? Because the signal object's name is "button_clicked".</li>
<li>It is impossible to express that two emitters emit the same signal, except by using the same identifier for their respective signal objects. However, the "sameness" is not expressed in code, it lives only in the head of the programmer.</li>
<li>Emitting a signal simply iterates the list of all connected functions maintained by each signal object.</li>
</ul></div>
<h3>Synapse</h3>
<p>In Synapse, emitters are explicit and signals are C++ types rather than objects. Signals are defined independently of any emitter. To connect a signal, we instantiate the <i>synapse::<span class="RenoLink"><a href="connect.html">connect</a></span></i> function template with the signal type we want to connect, passing the emitter object and the function we want connected. To emit a signal, we instantiate the <i>synapse::<span class="RenoLink"><a href="emit.html">emit</a></span></i> function template with the signal type, passing the emitter object, which calls all connected functions (if any).</p>
<p>Here is our example in terms of <i>Synapse</i>:</p>
<pre>typedef struct button_clicked_(*button_clicked)();

class button
{
  ....
  //Note: nothing from Synapse here, since it is non-intrusive.
  //Both button and dialog_box may be third-party types.
};

class dialog_box
{
  ....
public:
  void accept();
};</pre>
<p>To connect:</p>
<pre>dialog_box d;
button b;
shared_ptr&lt;<span class="RenoLink"><a href="connection.html">connection</a></span>&gt; c=<span class="RenoLink"><a href="connect.html">connect</a></span>&lt;button_clicked&gt;(&amp;b,bind(&amp;dialog_box::accept,&amp;d));</pre>
<p>To emit:</p>
<pre><span class="RenoLink"><a href="emit.html">emit</a></span>&lt;button_clicked&gt;(&amp;b);</pre>
<p>Things to note:</p>
<div><ul><li>Emitters are explicit: the call to <i><span class="RenoLink"><a href="emit.html">emit</a></span></i> requires the user to pass an emitter object;</li>
<li>Slots are simply functions, that is, they don't have to belong to an object (same as in <i>Signals2</i>);</li>
<li>The different semantics of the different signals are expressed by the different return types used to define signal types (a signal can't return a value);</li>
<li>Signals are not coupled with the emitter in any way: different emitters may emit the same signal.</li>
<li>Emitting a signal searches all connections of the specified signal type (but not connections of any other signal type), calling the connected function if the address of the emitter stored in the connection object matches the address of the emitter passed to <i><span class="RenoLink"><a href="emit.html">emit</a></span></i>.</li>
</ul></div>
<p>The most important differentiating feature of <i>Synapse</i> is that it is non-intrusive: emitting a signal does not require participation from the emitter object; that is, users can emit signals from any object whatsoever. For example, this is valid in <i>Synapse</i>:</p>
<pre>typedef struct my_signal_(*my_signal)();
int x;
<span class="RenoLink"><a href="emit.html">emit</a></span>&lt;my_signal&gt;(&amp;x);</pre>
<p>This allows two or more contexts under user control to communicate through any object (that acts as an emitter) shared between them, using different signals to communicate different messages.</p>
<h3>Thread safety</h3>
<p><i>Signals2</i> is thread-safe, meaning that it is safe to use a signal object from multilpe threads, however it provides nothing to facilitate thread safety in connected user functions. Its thread safety comes with the typical cost of using objects (in this case signal objects) shared between multiple threads.</p>
<p>In contrast, <i>Synapse</i>'s internal machinery uses <i>thread_local</i> storage, so creating or destroying connections doesn't need any locks. In addition, it provides <span class="RenoLink"><a href="interthread_communication_support.html">interthread communication support</a></span>, where signals can be emitted asynchronously from any thread, but consumed synchronously from other threads. This is especially useful in the context of user interface systems: for example, worker threads may emit signals to update various user interface elements, but the actual update can occur synchronously in the main UI thread.</p>
<h3>Meta signals</h3>
<p>In <i>Synapse</i>, connecting and disconnecting (also blocking and unblocking) signals emits signals from the special <i><span class="RenoLink"><a href="meta_emitter.html">meta::emitter</a></span></i> object. This allows users to translate between other signaling/notification/messaging APIs and <i>Synapse</i> signals. For example, when the user calls <i><span class="RenoLink"><a href="connect.html">connect</a></span>&lt;S&gt;</i>, the <i><span class="RenoLink"><a href="meta_emitter.html">meta::emitter</a></span></i> emits the signal <i><span class="RenoLink"><a href="meta_connected.html">meta::connected</a></span>&lt;S&gt;</i>. A function connected to that signal can then use a different library's API to forward its notifications to an appropriate call to <i><span class="RenoLink"><a href="emit.html">emit</a></span>&lt;S&gt;</i>; see "<span class="RenoLink"><a href="using_meta_signals_to_connect_to_a_C-style_callback_API.html">using meta signals to connect to a C-style callback API</a></span>".</p>
<h3>Reduced physical coupling</h3>
<p><i>Synapse</i> has the interesting feature that the <i><span class="RenoLink"><a href="emit.html">emit</a></span></i> function template is physically decoupled from the rest of the library. This means that a library that only emits (but never connects) signals needs not <b>link</b> <i>Synapse</i>.</p>
<p>Similarly, if the user never calls <i><span class="RenoLink"><a href="connect.html">connect</a></span></i> from multiple threads and never creates <i>thread_local_queue</i> objects, <i>Synapse</i>'s interthread communication components are never reached so there is no thread-safety overhead.</p>
</div><div class="RenoAutoDIV"><div class="RenoHR"><hr/></div>
See also: <span class="RenoPageList"><a href="index.html">Boost Synapse</a></span>
</div>
<!-- Copyright (c) 2008-2013 Emil Dotchevski and Reverge Studios, Inc. -->
<!-- Distributed under the Boost Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<div id="footer">
<p>
<a class="logo" href="http://jigsaw.w3.org/css-validator/check/referer"><img class="logo_pic" src="valid-css.png" alt="Valid CSS" height="31" width="88"/></a>
<a class="logo" href="http://validator.w3.org/check?uri=referer"><img class="logo_pic" src="valid-xhtml.png" alt="Valid XHTML 1.0" height="31" width="88"/></a>
<small>Copyright (c) 2015 by Emil Dotchevski and Reverge Studios, Inc.<br/>
Distributed under the <a href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License, Version 1.0</a>.</small>
</p>
</div>
</div>
</div>
</div>
</body>
</html>
