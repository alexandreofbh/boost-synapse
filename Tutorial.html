<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN'
'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>
<head>
	<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
	<title>Tutorial</title>
	<link href='reno.css' type='text/css' rel='stylesheet'/>
</head>
<body>
<div class="body-0">
<div class="body-1">
<div class="body-2">
<div>
<h1><a href="index.html">Boost Synapse</a></h1>
</div>
<!-- Copyright (c) 2015 Emil Dotchevski and Reverge Studios, Inc. -->
<!-- Distributed under the Boost Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<div class="RenoIncludeDIV"><p>This is a short introduction to <i><span class="RenoLink"><a href="index.html">Boost Synapse</a></span></i>. There are also several complete <span class="RenoLink"><a href="Examples.html">example programs</a></span> that may be of interest to the beginner.</p>
<h3>Defining signals</h3>
<p>Defining signals is very simple. For example, to define a <i>mouse_move</i> signal that takes two ints we could use:</p>
<pre>typedef struct mouse_move_(*mouse_move)( int x, int y );</pre>
<p>The return type (in this case <i>mouse_move_</i>) is ignored when the signal is emitted. Instead, it is used to tell apart different signals that take the same arguments. For example, the <i>button_down</i> signal defined below is different from <i>mouse_move</i> even though they both take two ints:</p>
<pre>typedef struct button_down_(*button_down)( int x, int y );</pre>
<p>That's it! Now we're ready to emit signals!</p>
<h3>Emitting signals</h3>
<p>To emit a signal simply call <i><span class="RenoLink"><a href="emit.html">emit</a></span></i> passing an emitter object. Any object of any type whatsoever can be used as an emitter. For example, from a member function we could pass <i>this</i> as the emitter:</p>
<pre>//Define a button_clicked signal that takes no arguments.
typedef struct button_clicked_(*button_clicked)();

class
my_button
    {
    ....
    void
    emit_button_clicked()
        {
        synapse::<span class="RenoLink"><a href="emit.html">emit</a></span>&lt;button_clicked&gt;(this);
        }
    };</pre>
<p>Of course, while the above call is well defined, it will not invoke any functions because we haven't connected anything to the signal yet.</p>
<h3>Connecting signals</h3>
<p>We have defined and emitted a signal, but to respond to it we need to connect it to a function. This is done using <i><span class="RenoLink"><a href="connect.html">connect</a></span></i>, which returns a <i><span class="RenoLink"><a href="connection.html">connection</a></span></i> object. For example:</p>
<pre>my_button b;
boost::shared_ptr&lt;synapse::<span class="RenoLink"><a href="connection.html">connection</a></span>&gt; c=synapse::<span class="RenoLink"><a href="connect.html">connect</a></span>&lt;button_clicked&gt;(&amp;b,f);</pre>
<p>This connects the <i>button_clicked</i> signal from the <i>my_button</i> object <i>b</i> to the function object <i>f</i>, which of course must match the signature of the signal being connected—in this case <i>f</i> must be a function that takes no arguments. Calling <i><span class="RenoLink"><a href="emit.html">emit</a></span></i> invokes all function objects that are connected to the specified emitter, in the order they have been connected.</p>
<p>To break the <i>button_clicked</i> connection between <i>b</i> and <i>f</i>, simply let the <i><span class="RenoLink"><a href="connection.html">connection</a></span></i> object expire. Optionally <i><span class="RenoLink"><a href="connect.html">connect</a></span></i> takes a third <i>weak_ptr&lt;void const&gt;</i> argument. If specified, <i><span class="RenoLink"><a href="emit.html">emit</a></span></i> will lock it before invoking the connected function and will not call the function if the <i>weak_ptr</i> has expired. For example this is useful if <i>f</i> binds a member function of an object managed by <i>shared_ptr</i> to ensure that <i><span class="RenoLink"><a href="emit.html">emit</a></span></i> does not invoke it if the object has expired:</p>
<pre>class
target
    {
    public:
    target(....);
    void do_something();
    };

my_button b;
boost::shared_ptr&lt;target&gt; t=boost::make_shared&lt;target&gt;(....);
boost::shared_ptr&lt;synapse::<span class="RenoLink"><a href="connection.html">connection</a></span>&gt; c=synapse::<span class="RenoLink"><a href="connect.html">connect</a></span>&lt;button_clicked&gt;(&amp;b,
    boost::bind(&amp;target::do_something,t.get()),t);

synapse::<span class="RenoLink"><a href="emit.html">emit</a></span>&lt;button_clicked&gt;(); //invokes t-&gt;do_something().
t.reset();
synapse::<span class="RenoLink"><a href="emit.html">emit</a></span>&lt;button_clicked&gt;(); //does not invoke t-&gt;do_something().</pre>
<p>We have passed <i>t</i> as the third argument to <i><span class="RenoLink"><a href="connect.html">connect</a></span></i>, and now the connection retains a <i>weak_ptr</i> to <i>t</i>. This allows <i><span class="RenoLink"><a href="index.html">Boost Synapse</a></span></i> to detect that by the time the second call to <i><span class="RenoLink"><a href="emit.html">emit</a></span>&lt;button_clicked&gt;()</i> occurs the target has expired, and so <i>t-&gt;do_something()</i> will not be invoked—even though the <i><span class="RenoLink"><a href="connection.html">connection</a></span></i> object <i>c</i> is still afloat.</p>
<p>Notice that in the call to <i>boost::bind</i> we pass <i>t.get()</i> rather than <i>t</i>. Had we passed <i>t</i>, the function object <i>bind</i> returns would be keeping the target afloat—which is a valid design choice but not what we wanted in this case. Passing a raw poither is safe because when <i><span class="RenoLink"><a href="emit.html">emit</a></span></i> calls a connected function, it first locks the <i>weak_ptr</i> passed to <i><span class="RenoLink"><a href="connect.html">connect</a></span></i>. </p>
<h3>Emitting signals from objects of 3rd-party types</h3>
<p>Recall that any object whatsoever can be used as an emitter. This makes it possible to emit non-intrusively even if the emitter object is not built to support signals. For example, a function that processes a file can use the standard <i>FILE</i> pointer as a <i><span class="RenoLink"><a href="index.html">Boost Synapse</a></span></i> emitter to report on its progress:</p>
<pre>typedef struct report_progress_(*report_progress)(int);

void
process_file( FILE * f )
    {
    for( int progress=0; !feof(f); )
        {
        ....
        progress += fread(buf,1,nread,f);
        synapse::<span class="RenoLink"><a href="emit.html">emit</a></span>&lt;report_progress&gt;(f,progress);
        }
    }</pre>
<p>Outside of <i>process_file</i> the <i>report_progress</i> signal can be connected to some user interface function that updates a progress bar. Using <i><span class="RenoLink"><a href="www.qt.io">Qt</a></span></i>, this could look like this:</p>
<pre>if( FILE * f=fopen("file.dat","rb") )
    {
    <span class="RenoLink"><a href="https://www.google.com/search?q=QProgressBar">QProgressBar</a></span> pb(....);
    auto c=synapse::<span class="RenoLink"><a href="connect.html">connect</a></span>&lt;report_progress&gt;(f,boost::bind(&amp;QProgressBar::setValue,&amp;pb,_1));
    process_file(f);
    }</pre>
<p>Notice that <i>process_file</i> is not coupled with <i>QProgressBar</i>: the <i>report_progress</i> signal could be connected to a different function or not connected at all, in which case the call to <i><span class="RenoLink"><a href="emit.html">emit</a></span></i> would be a no-op.</p>
<p>For another example of calling <i><span class="RenoLink"><a href="emit.html">emit</a></span></i> on an object of a 3rd-party type see "<span class="RenoLink"><a href="handling_events_from_an_OS_message_pump.html">Handling Events from an OS Message Pump</a></span>".</p>
<h3>Interoperability with other signal programming APIs</h3>
<p><i><span class="RenoLink"><a href="index.html">Boost Synapse</a></span></i> can be used to extend the functionality of other signal programming APIs. Suppose we call <i>synapse::<span class="RenoLink"><a href="connect.html">connect</a></span></i> with an object of type <i><span class="RenoLink"><a href="https://www.google.com/search?q=QPushButton">QPushButton</a></span></i>:</p>
<pre>//Define a <span class="RenoLink"><a href="index.html">Boost Synapse</a></span> signal.
typedef void QPushButton_clicked_(*QPushButton_clicked)();

....
QPushButton b;
boost::shared_ptr&lt;synapse::<span class="RenoLink"><a href="connection.html">connection</a></span>&gt; c=synapse::<span class="RenoLink"><a href="connect.html">connect</a></span>&lt;QPushButton_clicked&gt;(&amp;b,f);</pre>
<p>Now we can call <i>synapse::<span class="RenoLink"><a href="emit.html">emit</a></span></i> "manually" to make the <i>QPushButton</i> emit our <i>QPushButton_clicked</i> signal (which in this case will call <i>f</i> as long as the connection is alive):</p>
<pre>synapse::<span class="RenoLink"><a href="emit.html">emit</a></span>&lt;QPushButton_clicked&gt;(&amp;b);</pre>
<p>As is the case with the previous <i>FILE</i> pointer example, due to the non-intrusive nature of <i><span class="RenoLink"><a href="index.html">Boost Synapse</a></span></i>, emitting the <i>QPushButton_clicked</i> signal does not require cooperation from the <i>QPushButton</i> type itself.</p>
<blockquote><p><i>Note: This technique can be used to define new types of signals for existing </i>Qt<i> types, which is not supported by the native Qt API (in Qt, to add custom signals to a button we must define a new type that derives from QPushButton, which then must be passed through the proprietary Qt Meta Object Compiler, which is difficult without qmake). For a complete example see "<span class="RenoLink"><a href="adding_custom_signals_to_Qt_objects_without_MOCing.html">Adding Custom Signals to Qt Objects Without MOCing</a></span>"</i>.</p></blockquote>
<p>We can also make the <i>QPushButton</i> call <i><span class="RenoLink"><a href="emit.html">emit</a></span>&lt;QPushButton_clicked&gt;</i> automatically when clicked by connecting its native <i>QPushButton::clicked</i> signal (using the <i>Qt</i> API) to <i>synapse::<span class="RenoLink"><a href="emit.html">emit</a></span></i>:</p>
<pre><span class="RenoLink"><a href="https://www.google.com/search?q=QObject">QObject</a></span>::connect(&amp;b,
    &amp;QPushButton::clicked,boost::bind(&amp;synapse::emit&lt;QPushButton_clicked&gt;,&amp;b);</pre>
<h3>Meta signals</h3>
<p>In the above example, even though clicking the <i>QPushButton</i> calls <i><span class="RenoLink"><a href="emit.html">emit</a></span>&lt;QPushButton_clicked&gt;</i> automatically, the setup was not automatic. This can be improved by using meta signals.</p>
<p>Every time <i><span class="RenoLink"><a href="connect.html">connect</a></span>&lt;QPushButton_clicked&gt;</i> is called, the global <i><span class="RenoLink"><a href="meta_emitter.html">meta::emitter</a></span></i> emits the special signal <i><span class="RenoLink"><a href="meta_connected.html">meta::connected</a></span>&lt;QPushButton_clicked&gt;</i>. A possible handler of this signal may be declared like this:</p>
<pre>void handle_QPushButton_clicked_connect( synapse::<span class="RenoLink"><a href="connection.html">connection</a></span> &amp; c, unsigned flags );</pre>
<p>The first parameter, <i>c</i>, refers to the <i><span class="RenoLink"><a href="connection.html">connection</a></span></i> object created by <i><span class="RenoLink"><a href="connect.html">connect</a></span>&lt;QPushButton_clicked&gt;</i>. The second parameter is a combination of bits which depends on the circumstances in which the handler is invoked. In particular, the <i>connecting</i> bit is set when the <i><span class="RenoLink"><a href="connection.html">connection</a></span></i> object is being created; the meta signal is also emitted just as the <i><span class="RenoLink"><a href="connection.html">connection</a></span></i> object is expiring, in which case the <i>connecting</i> bit is not set.</p>
<p>Regardless, the handler may use <i><span class="RenoLink"><a href="connection_emitter.html">connection::emitter</a></span></i> to access the emitter object passed to <i><span class="RenoLink"><a href="connect.html">connect</a></span></i>:</p>
<pre>void
handle_QPushButton_clicked_connect( synapse::<span class="RenoLink"><a href="connection.html">connection</a></span> &amp; c, unsigned flags )
    {
    if( flags&amp;synapse::<span class="RenoLink"><a href="meta_connected.html">meta::connect_flags::connecting</a></span> )
        {
        boost::shared_ptr&lt;QPushButton&gt; b=c.<span class="RenoLink"><a href="connection_emitter.html">emitter</a></span>&lt;QPushButton&gt;();
        QMetaObject::Connection qc=QObject::connect(b.get(),&amp;QPushButton::clicked,
            boost::bind(&amp;synapse::<span class="RenoLink"><a href="emit.html">emit</a></span>&lt;QPushButton_clicked&gt;,b.get()));
        c.<span class="RenoLink"><a href="connection_set_user_data.html">set_user_data</a></span>(qc);
        }
    else
        QObject::disconnect(*c.<span class="RenoLink"><a href="connection_get_user_data.html">get_user_data</a></span>&lt;QMetaObject::Connection&gt;());
    }</pre>
<p>Calling <i>c.<span class="RenoLink"><a href="connection_emitter.html">emitter</a></span>&lt;QPushButton&gt;</i> returns the <i>QPushButton</i> object being passed to the call to <i><span class="RenoLink"><a href="connect.html">connect</a></span>&lt;QPushButton_clicked&gt;</i> which triggered our handler. Next, we use the <i>Qt</i> API to connect the <i>Qt</i>-native <i>QPushButton::clicked</i> signal to <i>synapse::<span class="RenoLink"><a href="emit.html">emit</a></span></i>, storing the resulting <i>Qt</i> connection object into <i>c</i> using <i><span class="RenoLink"><a href="connection_set_user_data.html">set_user_data</a></span></i> (which can be used to store a value of any type in <i>c</i>). When the <i>synapse::<span class="RenoLink"><a href="connection.html">connection</a></span></i> expires (the <i>else</i> branch), we retrieve the <i>Qt</i> connection from the <i>synapse::<span class="RenoLink"><a href="connection.html">connection</a></span></i> using <i><span class="RenoLink"><a href="connection_get_user_data.html">get_user_data</a></span></i> and pass it to <i>QObject::disconnect</i>.</p>
<p>All that remains is to connect the <i>handle_QPushButton_clicked_connect</i> function to the <i><span class="RenoLink"><a href="meta_emitter.html">meta::emitter</a></span></i>. This can be done by a simple namespace-scope call to <i><span class="RenoLink"><a href="connect.html">connect</a></span></i> placed in the same compilation unit that defines the handler:</p>
<pre>auto meta_QPushButton_clicked=synapse::<span class="RenoLink"><a href="connect.html">connect</a></span>&lt;synapse::<span class="RenoLink"><a href="meta_connected.html">meta::connected</a></span>&lt;QPushButton_clicked&gt; &gt;(
    synapse::<span class="RenoLink"><a href="meta_emitter.html">meta::emitter</a></span>(),&amp;handle_QPushButton_clicked_connect);</pre>
<p>We can now directly pass <i>QPushButton</i> objects to <i><span class="RenoLink"><a href="connect.html">connect</a></span></i> to install handlers for <i>QPushButton_clicked</i> to be invoked when buttons are clicked:</p>
<pre>QPushButton b1, b2;
    {
    //Make two QPushButton_clicked <span class="RenoLink"><a href="connection.html">connection</a></span>s: this also emits the
    //synapse::<span class="RenoLink"><a href="meta_connected.html">meta::connected</a></span>&lt;QPushButton_clicked&gt; signal twice,
    //each time triggering our installed handler which connects the Qt-native
    //signal QPushButton::clicked to synapse::emit&lt;QPushButton_clicked&gt;.
    boost::shared_ptr&lt;<span class="RenoLink"><a href="connection.html">connection</a></span>&gt; c1=synapse::<span class="RenoLink"><a href="connect.html">connect</a></span>&lt;QPushButton_clicked&gt;(&amp;b1,f1);
    boost::shared_ptr&lt;<span class="RenoLink"><a href="connection.html">connection</a></span>&gt; c2=synapse::<span class="RenoLink"><a href="connect.html">connect</a></span>&lt;QPushButton_clicked&gt;(&amp;b2,f2);
    ....
    //Until c1 and c2 expire clicking b1 calls f1 and clicking b2 calls f2.
    ....
    }
//At this point c1 and c2 have expired, emitting <span class="RenoLink"><a href="meta_connected.html">meta::connected</a></span>&lt;QPushButton_clicked&gt;
//twice again, each time triggering our intalled handler to disconnect the Qt-native signal.</pre>
<p>This documentation includes two complete example programs that illustrate the use of <i><span class="RenoLink"><a href="meta_connected.html">meta::connected</a></span></i> handlers:</p>
<div><ul><li> "<span class="RenoLink"><a href="using_meta_signals_to_connect_to_a_C-style_callback_API.html">Using Meta Signals to Connect to a C-Style Callback API</a></span>", and</li>
<li> "<span class="RenoLink"><a href="using_meta_signals_with_QPushButton.html">Using Meta Signals with QPushButton</a></span>".</li>
</ul></div>
<h3>Emitter lifetime safety</h3>
<p>Because the emitter object passed to <i><span class="RenoLink"><a href="connect.html">connect</a></span></i> may have been destroyed by the time it is accessed by a handler of the <i><span class="RenoLink"><a href="meta_connected.html">meta::connected</a></span></i> signal, <i><span class="RenoLink"><a href="connect.html">connect</a></span></i> can also take the emitter argument by <i>weak_ptr</i>:</p>
<pre>boost::shared_ptr&lt;my_button&gt; b(new my_button);
boost::shared_ptr&lt;synapse::<span class="RenoLink"><a href="connection.html">connection</a></span>&gt; c=synapse::<span class="RenoLink"><a href="connect.html">connect</a></span>&lt;button_clicked&gt;(b,f);</pre>
<p>In this case the <i><span class="RenoLink"><a href="connection.html">connection</a></span></i> retains a copy of the passed <i>weak_ptr</i> which will be locked by a later call to <i>c.<span class="RenoLink"><a href="connection_emitter.html">emitter</a></span>&lt;my_button&gt;()</i> to return a <i>shared_ptr</i> to the emitter. If instead <i><span class="RenoLink"><a href="connect.html">connect</a></span></i> was given a raw pointer, the <i>shared_ptr</i> returned by <i>c.<span class="RenoLink"><a href="connection_emitter.html">emitter</a></span>&lt;my_button&gt;()</i> still points to the emitter object but does not keep it afloat.</p>
<h3>Emitter type safety</h3>
<p>The <i><span class="RenoLink"><a href="connection_emitter.html">connection::emitter</a></span></i> function template is type-safe: the type of the emitter object is captured at the time it is passed to <i><span class="RenoLink"><a href="connect.html">connect</a></span></i>, and then <i><span class="RenoLink"><a href="connection_emitter.html">connection::emitter</a></span></i> returns an empty <i>shared_ptr</i> if the type it is instantiated with is incompatible with the captured type.</p>
<p>One complication with <i><span class="RenoLink"><a href="connection_emitter.html">connection::emitter</a></span></i> is that it is not aware of any possible implicit coversions if the emitter type is part of a class hierarchy. For example:</p>
<pre>boost::shared_ptr&lt;QPushButton&gt; b(....);
boost::shared_ptr&lt;synapse::<span class="RenoLink"><a href="connection.html">connection</a></span>&gt; c=synapse::<span class="RenoLink"><a href="connect.html">connect</a></span>&lt;QPushButton_clicked&gt;(b,f);
boost::shared_ptr&lt;QWidget&gt; w=c.<span class="RenoLink"><a href="connection_emitter.html">emitter</a></span>&lt;QWidget&gt;(); //fail</pre>
<p>We've passed the emitter to <i><span class="RenoLink"><a href="connect.html">connect</a></span></i> as a <i>QPushButton</i>, and later—knowing that <i>QWidget</i> is a base class of <i>QPushButton</i>—we want to access it as a <i>QWidget</i>. Currently this is not supported; the only way to deal with this problem is to try different base types:</p>
<pre>if( boost::shared_ptr&lt;QPushButton&gt; b=c.<span class="RenoLink"><a href="connection_emitter.html">emitter</a></span>&lt;QPushButton&gt;() )
    {
    /* <span class="RenoLink"><a href="connect.html">connect</a></span> was given a QPushButton. */
    }
else if( boost::shared_ptr&lt;QWidget&gt; w=c.<span class="RenoLink"><a href="connection_emitter.html">emitter</a></span>&lt;QWidget&gt;() )
    {
    /* <span class="RenoLink"><a href="connect.html">connect</a></span> was given a QWidget. */
    }
else if( boost::shared_ptr&lt;QObject&gt; o=c.<span class="RenoLink"><a href="connection_emitter.html">emitter</a></span>&lt;QObject&gt;() )
    {
    /* <span class="RenoLink"><a href="connect.html">connect</a></span> was given a QObject. */
    }
else if( boost::shared_ptr&lt;void const&gt; p=c.<span class="RenoLink"><a href="connection_emitter.html">emitter</a></span>&lt;void const&gt;() )
    {
    /* <span class="RenoLink"><a href="connect.html">connect</a></span> was given some other type. */
    }
else
    {
    /* Because any type can be accessed as void const,
        hitting this "else" branch means that the emitter has expired. */
    }</pre>
<p>Note however that <i><span class="RenoLink"><a href="connection_emitter.html">connection::emitter</a></span></i> does handle const-ness correctly. For example, if <i><span class="RenoLink"><a href="connect.html">connect</a></span></i> was passed a <i>QPushButton</i> emitter, it can be accessed as <i>QPushButton</i> and as <i>QPushButton const</i>, but if <i><span class="RenoLink"><a href="connect.html">connect</a></span></i> was passed a <i>QPushButton const</i> then it can not be accessed as a <i>QPushButton</i>.</p>
<h3>Blocking signals</h3>
<p>It is possible to block a specific signal for a specific emitter. While the signal is blocked, calls to <i><span class="RenoLink"><a href="emit.html">emit</a></span></i> are ignored:</p>
<pre>my_button b;
boost::shared_ptr&lt;synapse::<span class="RenoLink"><a href="connection.html">connection</a></span>&gt; c=synapse::<span class="RenoLink"><a href="connect.html">connect</a></span>&lt;button_clicked&gt;(&amp;b,f);
    {
    boost::shared_ptr&lt;synapse::<span class="RenoLink"><a href="blocker.html">blocker</a></span>&gt; blk=synapse::<span class="RenoLink"><a href="block.html">block</a></span>&lt;button_clicked&gt;(&amp;b);
    synapse::<span class="RenoLink"><a href="emit.html">emit</a></span>&lt;button_clicked&gt;(&amp;b); //Doesn't call any handlers, button_clicked is blocked.
    }

//Here blk has expired, unblocking the button_clicked signal for b.
//The following call to emit will call the connected handlers.
synapse::<span class="RenoLink"><a href="emit.html">emit</a></span>&lt;button_clicked&gt;(&amp;b);</pre>
<p>In general, a signal will remain blocked for a given emitter until all <i><span class="RenoLink"><a href="blocker.html">blocker</a></span></i> objects for that signal and that emitter have expired. Note that blocking a signal affects current as well as future connections:</p>
<pre>my_button b;
boost::shared_ptr&lt;synapse::<span class="RenoLink"><a href="blocker.html">blocker</a></span>&gt; blk=synapse::<span class="RenoLink"><a href="block.html">block</a></span>&lt;button_clicked&gt;(&amp;b);
boost::shared_ptr&lt;synapse::<span class="RenoLink"><a href="connection.html">connection</a></span>&gt; c=synapse::<span class="RenoLink"><a href="connect.html">connect</a></span>&lt;button_clicked&gt;(&amp;b,f);

synapse::<span class="RenoLink"><a href="emit.html">emit</a></span>&lt;button_clicked&gt;(&amp;b); //Doesn't call any handlers, button_clicked is blocked.</pre>
<p>In addition (similarly to <i><span class="RenoLink"><a href="connect.html">connect</a></span></i>) there is a meta signal associated with <i><span class="RenoLink"><a href="block.html">block</a></span></i>. When a specific signal for a specific emitter transitions from being unblocked to being blocked, the <i><span class="RenoLink"><a href="meta_emitter.html">meta::emitter</a></span></i> emits <i><span class="RenoLink"><a href="meta_blocked.html">meta::blocked</a></span></i>, passing <i>true</i> for its <i>is_blocked</i> argument. The signal is emitted again when the signal becomes unblocked and this time <i>is_blocked</i> is <i>false</i>. One possible use of <i><span class="RenoLink"><a href="meta_blocked.html">meta::blocked</a></span></i> is to automatically reflect the blocked state of the signal in some user interface; see "<span class="RenoLink"><a href="using_meta_signals_to_respond_to_signals_being_blocked_or_unblocked.html">Using Meta Signals to Respond to Signals Being Blocked or Unblocked</a></span>".</p>
<h3>Multi-threading support</h3>
<p>Please see <span class="RenoLink"><a href="interthread_communication_support.html">Interthread Communication Support</a></span>.</p>
<h3>Header-only emit</h3>
<p>If no signals are ever connected, <i>emit</i> is a no-op. For this reason, if a user library calls <i><span class="RenoLink"><a href="emit.html">emit</a></span></i> but does not call <i><span class="RenoLink"><a href="connect.html">connect</a></span></i>, and if the program that links the user library does not call <i>connect</i> either, there is no need to link the <i><span class="RenoLink"><a href="index.html">Boost Synapse</a></span></i> library. As an example, a low level library that emits signals similar to <i>report_progress</i> (see the <i>FILE</i> example earlier on this page) can do so without requiring a client program that doesn't care about them to link <i><span class="RenoLink"><a href="index.html">Boost Synapse</a></span></i>—yet other client programs that do connect and handle the signals will "just work" without needing to recompile the low level library.</p>
</div><div class="RenoAutoDIV"><div class="RenoHR"><hr/></div>
See also: <span class="RenoPageList"><a href="index.html">Boost Synapse</a></span>
</div>
<!-- Copyright (c) 2008-2013 Emil Dotchevski and Reverge Studios, Inc. -->
<!-- Distributed under the Boost Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<div id="footer">
<p>
<a class="logo" href="http://jigsaw.w3.org/css-validator/check/referer"><img class="logo_pic" src="valid-css.png" alt="Valid CSS" height="31" width="88"/></a>
<a class="logo" href="http://validator.w3.org/check?uri=referer"><img class="logo_pic" src="valid-xhtml.png" alt="Valid XHTML 1.0" height="31" width="88"/></a>
<small>Copyright (c) 2015 by Emil Dotchevski and Reverge Studios, Inc.<br/>
Distributed under the <a href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License, Version 1.0</a>.</small>
</p>
</div>
</div>
</div>
</div>
</body>
</html>
