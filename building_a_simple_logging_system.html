<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN'
'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>
<head>
	<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
	<title>building a simple logging system</title>
	<link href='reno.css' type='text/css' rel='stylesheet'/>
</head>
<body>
<div class="body-0">
<div class="body-1">
<div class="body-2">
<div>
<div id="reverge_logo">
<a href="http://www.revergestudios.com"><img style="border:0" src="reverge.png" alt="Reverge"/></a>
</div>
<h1><a href="index.html">Boost Synapse</a></h1>
</div>
<!-- Copyright (c) 2015 Emil Dotchevski and Reverge Studios, Inc. -->
<!-- Distributed under the Boost Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<div class="RenoIncludeDIV"><div class="RenoAutoDIV"><h3>Building a Simple Logging System</h3>
</div>
<p>This program demonstrates how to use <i><span class="RenoLink"><a href="index.html">Boost Synapse</a></span></i> to build a simple logging system. Logging is done by emitting <i>log_message</i> <span class="RenoLink"><a href="Signal.html">signals</a></span> from different emitters based on the log message's severity.</p>
<p>It consists of the following source files:</p>
<div><ul><li> <i>logger.h/logger.cpp</i>: these files implement the logging interface;</li>
<li> <i>main.cpp</i>: a simple program using the interface defined in <i>logger.h</i>.</li>
</ul></div>
<p><b>Program output:</b></p>
<pre>Message 1, Severity 0
Message 2, Severity 100
Message 2, Severity 100
Message 3, Severity 2
Message 3, Severity 2</pre>
<p><b>logger.h:</b></p>
<pre>namespace boost { template &lt;class&gt; class shared_ptr; }
namespace boost { template &lt;class&gt; class weak_ptr; }

#include &lt;stdio.h&gt;

struct logger;

//Create a logger object that can discriminate between messages based on severity up to the
//specified maximum. Messages with higher max_severity are assumed to be of max_severity.
boost::shared_ptr&lt;logger&gt; init_logger( int max_severity );

//Add a target for logging messages with at least the specified severity.
void add_log_target( logger &amp;, boost::shared_ptr&lt;FILE&gt; const &amp;, int min_severity );

//Get a Boost Synapse emitter based on the message's severity.
void const * severity( int severity );

//Emit this Boost Synapse <span class="RenoLink"><a href="Signal.html">signal</a></span> to log a message.
typedef struct log_message_(*log_message)( char const * );</pre>
<p><b>logger.cpp:</b></p>
<pre>#include "logger.h"
#include &lt;<span class="RenoLink"><a href="boost_synapse_translate_hpp.html">boost/synapse/translate.hpp</a></span>&gt;
#include &lt;vector&gt;

namespace synapse=boost::synapse;

namespace
    {
    //Emitters, indexed by severity.
    std::vector&lt;boost::weak_ptr&lt;void const&gt; &gt; emitters_;

    void
    log_string( boost::shared_ptr&lt;FILE&gt; const &amp; f, char const * str )
        {
        assert(f);
        assert(str!=0);
        (void) fprintf(f.get(),"%s",str);
        }

    boost::weak_ptr&lt;void const&gt; const &amp;
    severity_( int s )
        {
        assert(s&gt;=0);
        assert(!emitters_.empty());
        return s&gt;=emitters_.size()? emitters_.back() : emitters_[s];
        }
    }

struct
logger
    {
    private:
    logger( logger const &amp; );
    logger &amp; operator=( logger const &amp; );
    public:
    explicit
    logger( int max_severity )
        {
        std::vector&lt;boost::weak_ptr&lt;void const&gt; &gt;(max_severity).swap(emitters_);
        }
    std::vector&lt;boost::shared_ptr&lt;synapse::<span class="RenoLink"><a href="connection.html">connection</a></span>&gt; &gt; connections_;
    };

boost::shared_ptr&lt;logger&gt;
init_logger( int max_severity )
    {
    assert(max_severity&gt;0);
    boost::shared_ptr&lt;logger&gt; l(new logger(max_severity));

    //Populate the static emitters vector: each emitter is a weak_ptr initialized from a shared_ptr alias
    //of the logger object, but with a unique address.
    for( int i=0; i!=max_severity; ++i )
        emitters_[i]=boost::shared_ptr&lt;void const&gt;(l,&amp;emitters_[i]);

    //Translate signals from higher severity emitters to lower severity emitters. This way a high severity
    //message will automatically trickle down to lower severity emitters. With this approach it is possible
    //to build a more complex translation DAG if needed.
    for( int i=0; i!=max_severity-1; ++i )
        l-&gt;connections_.push_back(synapse::<span class="RenoLink"><a href="translate.html">translate</a></span>&lt;log_message,log_message&gt;(emitters_[i+1],emitters_[i].lock().get()));

    return l;
    }

void
add_log_target( logger &amp; l, boost::shared_ptr&lt;FILE&gt; const &amp; target, int min_severity )
    {
    assert(target);
    assert(min_severity&gt;=0);
    assert(min_severity&lt;emitters_.size());

    //Connect the appropriate emitter based on severity. Since signals from higher severity emitters are
    //translated to lower severities, the target will only get the messages with severity &gt;= min_severity.
    l.connections_.push_back(synapse::<span class="RenoLink"><a href="connect.html">connect</a></span>&lt;log_message&gt;(severity_(min_severity),boost::bind(&amp;log_string,target,_1)));
    }

void const *
severity( int s )
    {
    assert(s&gt;=0);
    assert(!emitters_.empty());
    return (s&gt;=emitters_.size()? emitters_.back() : emitters_[s]).lock().get();
    }</pre>
<p><b>main.cpp:</b></p>
<pre>#include "logger.h"
#include &lt;<span class="RenoLink"><a href="boost_synapse_emit_hpp.html">boost/synapse/emit.hpp</a></span>&gt;

namespace synapse=boost::synapse;

namespace { struct null_deleter { void operator()( void const * ) { } }; }

void
do_some_logging()
    {
    synapse::<span class="RenoLink"><a href="emit.html">emit</a></span>&lt;log_message&gt;(severity(0),"Message 1, Severity 0\n");
    synapse::<span class="RenoLink"><a href="emit.html">emit</a></span>&lt;log_message&gt;(severity(100),"Message 2, Severity 100\n");
    synapse::<span class="RenoLink"><a href="emit.html">emit</a></span>&lt;log_message&gt;(severity(2),"Message 3, Severity 2\n");
    }

int
main()
    {
    //Create a logger that can distinguish between up to 3 severity levels: 0, 1 and 2.
    boost::shared_ptr&lt;logger&gt; const l=init_logger(3);

    //Severity 0 and 1 go to stdout, severity 2 and above go to stdout and stderr.
    add_log_target(*l,boost::shared_ptr&lt;FILE&gt;(stdout,null_deleter()),0);
    add_log_target(*l,boost::shared_ptr&lt;FILE&gt;(stderr,null_deleter()),2);

    do_some_logging();
    }</pre>
</div><div class="RenoAutoDIV"></div>
<!-- Copyright (c) 2008-2013 Emil Dotchevski and Reverge Studios, Inc. -->
<!-- Distributed under the Boost Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<div id="footer">
<p>
<a class="logo" href="http://jigsaw.w3.org/css-validator/check/referer"><img class="logo_pic" src="valid-css.png" alt="Valid CSS" height="31" width="88"/></a>
<a class="logo" href="http://validator.w3.org/check?uri=referer"><img class="logo_pic" src="valid-xhtml.png" alt="Valid XHTML 1.0" height="31" width="88"/></a>
<small>Copyright (c) 2015 by Emil Dotchevski and Reverge Studios, Inc.<br/>
Distributed under the <a href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License, Version 1.0</a>.</small>
</p>
</div>
</div>
</div>
</div>
</body>
</html>
