<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN'
'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>
<head>
	<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
	<title>handling events from an OS message pump</title>
	<link href='reno.css' type='text/css' rel='stylesheet'/>
</head>
<body>
<div class="body-0">
<div class="body-1">
<div class="body-2">
<div>
<div id="reverge_logo">
<a href="http://www.revergestudios.com"><img style="border:0" src="reverge.png" alt="Reverge"/></a>
</div>
<h1><a href="index.html">Boost Synapse</a></h1>
</div>
<!-- Copyright (c) 2015 Emil Dotchevski and Reverge Studios, Inc. -->
<!-- Distributed under the Boost Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<div class="RenoIncludeDIV"><div class="RenoAutoDIV"><h3>Handling Events from an OS Message Pump</h3>
</div>
<p>This program demonstrates how Boost Synapse can be used to dispatch <i>WindowProc</i> messages using the <i>HWND</i> object as the emitter argument to <i>synapse::<span class="RenoLink"><a href="emit.html">emit</a></span></i>. It also shows how <i>boost::shared_ptr</i> can be used to control the lifetime of Windows objects.</p>
<pre>#include &lt;<span class="RenoLink"><a href="boost_synapse_connect_hpp.html">boost/synapse/connect.hpp</a></span>&gt;
#define NOMINMAX
#include &lt;windows.h&gt;
#include &lt;sstream&gt;

namespace synapse=boost::synapse;

namespace
    {
    //Define a mouse_move signal that takes the mouse cursor coordinates.
    typedef struct mouse_move_(*mouse_move)( int x, int y );

    //Windows handles are pointer typedefs. The code below extracts the pointer type
    //from the typedef so that it can be used with shared_ptr. This technique works for
    //all Windows handle types.
    template &lt;class T&gt; struct h_type;
    template &lt;class T&gt; struct h_type&lt;T *&gt; { typedef T type; };
    typedef h_type&lt;HWND&gt;::type hwnd_t;

    //This is our WindowProc registered with Windows. Its translates Windows messages
    //into calls to synapse::emit&lt;&gt;, passing the hWnd as the emitter object.
    LRESULT CALLBACK
    WindowProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
        {
        switch( uMsg )
            {
            default:
                return DefWindowProc(hWnd,uMsg,wParam,lParam);
            case WM_MOUSEMOVE:
                synapse::<span class="RenoLink"><a href="emit.html">emit</a></span>&lt;mouse_move&gt;(hWnd,lParam&amp;0xFFFF,(lParam&gt;&gt;16)&amp;0xFFFF);
                break;
            case WM_CLOSE:
                PostQuitMessage(0);
                break;
            }
        return 0;
        }

    //This function is connected to the mouse_move signal emitted by WindowProc.
    void
    print_mouse_position( HWND hWnd, int x, int y )
        {
        if( HDC dc=GetDC(hWnd) )
            {
            std::ostringstream str; str &lt;&lt; "Mouse position: " &lt;&lt; x &lt;&lt; ", " &lt;&lt; y;
            std::string s=str.str();
            RECT rect; GetClientRect(hWnd,&amp;rect);
            FillRect(dc,&amp;rect,(HBRUSH) GetStockObject(WHITE_BRUSH));
            TextOutA(dc,10,10,s.c_str(),s.size());
            ReleaseDC(hWnd,dc);
            }
        }
    }

int CALLBACK
WinMain( HINSTANCE hInstance, HINSTANCE, LPSTR, int )
    {
    //Register the Windows class.
    char const name[ ]="win_WindowProc";
    WNDCLASSEXA wcx; 
    wcx.cbSize = sizeof(wcx);
    wcx.style = CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS;
    wcx.lpfnWndProc = &amp;WindowProc;
    wcx.cbClsExtra = 0;
    wcx.cbWndExtra = 0;
    wcx.hInstance = hInstance;
    wcx.hIcon = 0;
    wcx.hCursor=LoadCursor(NULL,IDC_ARROW);
    wcx.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
    wcx.lpszMenuName =  0; 
    wcx.lpszClassName = name;
    wcx.hIconSm = 0;
    (void) RegisterClassExA(&amp;wcx);

    //Create a window and hold on to it by shared_ptr.
    boost::shared_ptr&lt;hwnd_t&gt; hWnd;
    if( HWND w=CreateWindowA(name,name,WS_OVERLAPPED|WS_CAPTION|WS_SYSMENU|WS_SIZEBOX,200,200,400,200,0,0,hInstance,0) )
        boost::shared_ptr&lt;hwnd_t&gt;(w,&amp;DestroyWindow).swap(hWnd);
    else
        return 1; //Error

    //Connect the mouse_move signal from the hWnd emitter to the print_mouse_position function.
    boost::shared_ptr&lt;synapse::<span class="RenoLink"><a href="connection.html">connection</a></span>&gt; conn=synapse::<span class="RenoLink"><a href="connect.html">connect</a></span>&lt;mouse_move&gt;(hWnd,
        [&amp;hWnd]( int x, int y )
            {
            print_mouse_position(hWnd.get(),x,y);
            } );

    //Show the window and call print_mouse_position once so it's not empty to begin with.
    ShowWindow(hWnd.get(),SW_SHOW);
    print_mouse_position(hWnd.get(),0,0);

    //Process messages -- this continues until the user closes the window.
    for( MSG msg; GetMessageA(&amp;msg,0,0,0); )
        {
        TranslateMessage(&amp;msg);
        DispatchMessage(&amp;msg);
        }
    return 0;
    }</pre>
</div><div class="RenoAutoDIV"><div class="RenoHR"><hr/></div>
See also: <span class="RenoPageList"><a href="Tutorial.html">Tutorial</a></span>
</div>
<!-- Copyright (c) 2008-2013 Emil Dotchevski and Reverge Studios, Inc. -->
<!-- Distributed under the Boost Software License, Version 1.0. (See accompanying -->
<!-- file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<div id="footer">
<p>
<a class="logo" href="http://jigsaw.w3.org/css-validator/check/referer"><img class="logo_pic" src="valid-css.png" alt="Valid CSS" height="31" width="88"/></a>
<a class="logo" href="http://validator.w3.org/check?uri=referer"><img class="logo_pic" src="valid-xhtml.png" alt="Valid XHTML 1.0" height="31" width="88"/></a>
<small>Copyright (c) 2015 by Emil Dotchevski and Reverge Studios, Inc.<br/>
Distributed under the <a href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License, Version 1.0</a>.</small>
</p>
</div>
</div>
</div>
</div>
</body>
</html>
